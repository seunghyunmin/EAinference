#' @title Bootstrapping lasso / group lasso estimator
#'
#' @description Draw bootstrap samples in parametric or nonparametric way and
#' derive (group) lasso estimator along with subgradient.
#'
#' @param X Predictor matrix.
#' @param pointEstimate_1,sig2_1,lbd_1 Parameter of target distribution.
#' (coefficient estimate, estimated variance of error, lambda). Not required for
#' \code{method = "normal"}.
#' @param pointEstimate_2,sig2_2,lbd_2 Additional Parameter of target distribution only
#' if mixture distribution is used. Not required for \code{method = "normal"}.
#' @param weights Weight vector in length of the number of groups. Default is
#' \code{rep(1, max(group))}.
#' @param group p x 1 vector of consecutive integers describing group structure.
#' The number of groups should be same as max(group). Default is \code{group = 1:p}
#' , where \code{p} is number of covariates.
#' @param niter The number of iterations.
#' @param method Bootstrap method, one of \code{"normal"} or \code{"nonparametric"}.
#' If \code{"normal"}, resample errors from normal distiribution. If \code{"nonparametric"},
#' resample errors from residuals.
#' @param Y Response vector. Needed only if \code{method="nonparametric"}.
#' @param parallel Logical. If \code{TRUE}, use parallelization.
#' @param ncores Integer. The number of cores to use for the parallelization.
#' @param verbose Whether to show the process. Default is FALSE. Only works when
#'  parallel=FALSE.
#'
#' @details This function provides bootstrap samples for (group) lasso estimator
#' and its subgradient. The sampling distribution is chracterized by \code{(pointEstimate, sig2, lbd)}.
#' First, we generate \code{y_new} by \code{X * pointEstimate + error_new}, while \code{error_new}
#' is generated by two distinct ways.
#' If \code{method="normal"}, error_new is generated from N(0, sig2).
#' If \code{method="nonparametric"}, error_new is resampled from the residuals,
#' y - X*pointEstimate. See Zhou(2014) and Zhou and Min(2016) for more details.
#'
#' If non-mixture distribution is used, the distribution with parameters \code{(pointEstimate_1, sig2_1, lbd_1)}
#' will be used.
#' If one uses mixture distribution by providing \code{(pointEstimate_2, sig2_2, lbd_2)},
#' with 1/2 chance, samples will be drawn from the distribution with
#' (pointEstimate_1, sig2_1, lbd_1) and with another 1/2 chance, they will be drawn from
#' the distribution with (pointEstimate_2, sig2_2, lbd_2).
#'
#' @return \item{beta}{(group) lasso estimator.}
#' @return \item{subgrad}{subgradient.}
#'
#' @examples
#' set.seed(1234)
#' n <- 10
#' p <- 30
#' Niter <-  10
#' Group <- rep(1:(p/10), each = 10)
#' Weights <- rep(1, p/10)
#' x <- matrix(rnorm(n*p), n)
#' #
#' # Using non-mixture distribution
#' #
#' DirectSampler(X = x, pointEstimate_1 = rep(0, p), sig2_1 = 1, lbd_1 = .5,
#'  weights = Weights, group = Group, niter = Niter, parallel = FALSE)
#' DirectSampler(X = x, pointEstimate_1 = rep(0, p), sig2_1 = 1, lbd_1 = .5,
#'  weights = Weights, group = Group, niter = Niter, parallel = TRUE)
#' #
#' # Using mixture distribution
#' #
#' DirectSampler(X = x, pointEstimate_1 = rep(0, p), sig2_1 = 1, lbd_1 = .5,
#'  pointEstimate_2 = rep(1, p), sig2_2 = 2, lbd_2 = .3, weights = Weights,
#'  group = Group, niter = Niter, parallel = TRUE)
#' @export
#'
DirectSampler <- function(X, pointEstimate_1, sig2_1, lbd_1, pointEstimate_2, sig2_2, lbd_2,
  lbd, weights = rep(1, max(group)), group = 1:ncol(X), niter = 2000,
  type = "coeff", method = "normal", Y, parallel = FALSE, ncores = 2L, verbose = FALSE)
{
  n <- nrow(X)
  p <- ncol(X)

  #--------------------
  # Error Handling
  #--------------------
  if (!type %in% c("coeff", "mu")) {
    stop("Invalide type input.")
  }

  if (!method %in% c("normal", "nonparametric")){
    stop("method needs to be either normal or nonparametric")
  }

  if (parallel && !missing(ncores) && ncores == 1) {
    ncores <- 2
    warning("If parallel=TRUE, ncores needs to be greater than 1. Automatically
            Set ncores to 2.")
  }

  if (parallel && (ncores > parallel::detectCores())) {
    ncores <- parallel::detectCores()
    warning("ncores is larger than the maximum number of available processes.
            Set it to the maximum possible value.")
  }

  if (missing(Y) && method == "nonparametric") {
    stop("Y is needed for the method=\"nonparametric\"")
  }

  if (length(group) != p) {
    stop("group must have a same length with the number of X columns")
  }
  if (length(weights) != length(unique(group))) {
    stop("weights has to have a same length as the number of groups")
  }
  if (any(!1:max(group) %in% group)) {
    stop("group index has to be a consecutive integer starting from 1.")
  }

  if (any(missing(pointEstimate_1), missing(sig2_1), missing(lbd_1))) {
    stop("provide all the parameters for the distribution")
  }
  if (all(group==1:p) && !sum(c(missing(sig2_2), missing(lbd_2),
                                missing(pointEstimate_2)))==3) {
    stop("Mixture distribution can be only used under group lasso.")
  }

  if (!sum(c(missing(sig2_2), missing(lbd_2), missing(pointEstimate_2)))
      %in% c(0, 3)) {
    stop("provide all the parameters for the mixture distribution.")
  }
  #--------------------
  # Main Step
  #--------------------
  Mixture <- !missing(sig2_2)

  if (Mixture) {
    niter1 <- rbinom(n = 1, size = niter, prob = 1/2)
    niter2 <- niter-niter1

    DS1 <- DirectSamplerMain(X = X, pointEstimate = pointEstimate_1, sig2 = sig2_1,
                         lbd = lbd_1, weights = weights, group = group, niter = niter1,
                         type = type, method = method, Y=Y, parallel = parallel, ncores = ncores, verbose = verbose)
    DS2 <- DirectSamplerMain(X = X, pointEstimate = pointEstimate_2, sig2 = sig2_1,
                         lbd = lbd_1, weights = weights, group = group, niter = niter2,
                         type = type, method = method, Y=Y, parallel = parallel, ncores = ncores, verbose = verbose)
    if (method == "normal") {
      RESULT <- list(beta = rbind(DS1$beta, DS2$beta),
        subgrad = rbind(DS1$subgrad, DS2$subgrad), X = X,
        pointEstimate = rbind(pointEstimate_1, pointEstimate_2),
        sig2 = c(sig2_1, sig2_2), lbd = c(lbd_1, lbd_2), weights = weights, group = group, method = method,
        type = type, mixture = FALSE)
    } else {
      RESULT <- list(beta = rbind(DS1$beta, DS2$beta),
        subgrad = rbind(DS1$subgrad, DS2$subgrad), X = X, Y = Y,
        pointEstimate = rbind(pointEstimate_1, pointEstimate_2),
        lbd = c(lbd_1, lbd_2), weights = weights, group = group, method = method,
        type = type, mixture = FALSE)
    }
  } else {
    DS <- DirectSamplerMain(X = X, pointEstimate = pointEstimate_1,
      sig2 = sig2_1, lbd = lbd_1, weights = weights, group = group,
      niter = niter, type = type, method = method, Y=Y, parallel = parallel,
      ncores = ncores, verbose = verbose)

    if (method == "normal") {
      RESULT <- list(beta = DS$beta, subgrad = DS$subgrad, X = X,
        pointEstimate = pointEstimate_1, sig2 = sig2_1, lbd = lbd_1, weights = weights, group = group,
        method = method, type = type, mixture = FALSE)
    } else {
      RESULT <- list(beta = DS$beta, subgrad = DS$subgrad, X = X, Y = Y,
        pointEstimate = pointEstimate_1, lbd = lbd_1, weights = weights, group = group,
        method = method, type = type, mixture = FALSE)
    }
  }
  class(RESULT) <- "DS"
  return(RESULT)
}

DirectSamplerMain <- function(X, pointEstimate, mu, sig2, lbd, weights = rep(1, max(group)),
 group = 1:ncol(X), niter = 2000, type = "coeff", method = "normal", Y, parallel = FALSE,
 ncores = 2L, verbose = FALSE)
{
  n <- nrow(X);
  p <- ncol(X);

  if (sig2 <= 0) {
    stop("sig2 should be positive.")
  }

  if (lbd < 0) {
    stop("lbd should be non-negative.")
  }

  if (any(weights < 0)) {
    stop("weights should be non-negative.")
  }

  if (length(sig2) !=1 || length(lbd) != 1) {
    stop("sig2/lbd should be a scalar.")
  }

  if (parallel && verbose) {
    warning("Note that verbose only works when parallel=FALSE")
  }
  if (type == "coeff" && length(pointEstimate) != p) {
    stop("pointEstimate must have a same length with the col-number of X, if type = \"coeff\"")
  }

  if (type == "mu" && length(pointEstimate) != n) {
    stop("pointEstimate must have a same length with the row-number of X, if type = \"mu\"")
  }

  if(verbose) {
    ptm <- proc.time();
    niter.seq <- round(seq(1, niter, length.out = 11))[-1]
  }

  W <- rep(weights, table(group))

  X.tilde   <- scale(X, FALSE, scale = W)
  t.X.tilde <- t(X.tilde) # same as  t(X) / W
  GramMat   <- t(X.tilde) %*% X.tilde
  Lassobeta <- matrix(0, niter, p)
  Subgrad   <- matrix(0, niter, p)
  Ysample   <- numeric(n)
  if (type == "coeff") {
    Yexpect <- X %*% pointEstimate
  } else {
    Yexpect <- pointEstimate
  }

  if(method == "nonparametric") {obsRed <- Y - Yexpect}

  FF <- function(x) {
    if (method == "normal")
    {
      epsilon <- rnorm(n, mean = 0, sd = sig2^0.5)
    }
    if (method == "nonparametric")
    {
      epsilon <- sample(obsRed, size = n, replace = TRUE);
    }
    Ysample <- Yexpect + epsilon;
    #if(center){Ysample=Ysample-mean(Ysample);}

    LassoFit <- gglasso(X.tilde, Ysample, pf = rep(1, max(group)),
                  group = group, loss = "ls", intercept = FALSE, lambda = lbd)
    Lassobeta <- coef(LassoFit)[-1] / W
    return(c(Lassobeta, (t.X.tilde %*% Ysample -
                           GramMat %*% (Lassobeta * W)) / n / lbd))
  }

  if (parallel == FALSE) {
    TEMP      <- lapply(1:niter, FF)
    TEMP      <- do.call(rbind, TEMP)
    Lassobeta <- TEMP[, 1:p]
    Subgrad   <- TEMP[, -c(1:p)]
  } else {
    TEMP <- parallel::mclapply(1:niter, FF, mc.cores = ncores)
    TEMP <- do.call(rbind, TEMP)
    Lassobeta <- TEMP[, 1:p]
    Subgrad <- TEMP[, -c(1:p)]
  }
  if (verbose) {print(proc.time() - ptm)}
  return(list(beta = Lassobeta, subgrad = Subgrad));
}
