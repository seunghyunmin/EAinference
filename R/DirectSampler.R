#' @title Bootstrapping lasso / group lasso estimator
#'
#' @description Draw bootstrap samples in parametric or nonparametric way and
#' derive (group) lasso estimator along with subgradient.
#'
#' @param X Predictor matrix.
#' @param coeff_1,sig2_1,lbd_1 Parameter of target distribution.
#' (coefficient estimate, estimated variance of error, lambda). Not required for
#' \code{type = "normal"}.
#' @param coeff_2,sig2_2,lbd_2 Additional Parameter of target distribution only
#' if mixture distribution is used. Not required for \code{type = "normal"}.
#' @param weights Weight vector in length of the number of groups. Default is
#' \code{rep(1, max(group))}.
#' @param group p x 1 vector of consecutive integers describing group structure.
#' The number of groups should be same as max(group). Default is \code{group = 1:p}
#' , where \code{p} is number of covariates.
#' @param niter The number of iterations.
#' @param type Bootstrap method, one of \code{"normal"} or \code{"nonparametric"}.
#' If \code{"normal"}, resample errors from normal distiribution. If \code{"nonparametric"},
#' resample errors from residuals.
#' @param Y Response vector. Needed only if \code{type="nonparametric"}.
#' @param parallel Logical. If \code{TRUE}, use parallelization.
#' @param ncores Integer. The number of cores to use for the parallelization.
#' @param verbose Whether to show the process. Default is FALSE. Only works when
#'  parallel=FALSE.
#'
#' @details This function provides bootstrap samples for (group) lasso estimator
#' and its subgradient. The sampling distribution is chracterized by \code{(coeff, sig2, lbd)}.
#' First, we generate \code{y_new} by \code{X * coeff + error_new}, while \code{error_new}
#' is generated by two distinct ways.
#' If \code{type="normal"}, error_new is generated from N(0, sig2).
#' If \code{type="nonparametric"}, error_new is resampled from the residuals,
#' y - X*coeff. See Zhou(2014) and Zhou and Min(2016) for more details.
#'
#' If non-mixture distribution is used, the distribution with parameters \code{(coeff_1, sig2_1, lbd_1)}
#' will be used.
#' If one uses mixture distribution by providing \code{(coeff_2, sig2_2, lbd_2)},
#' with 1/2 chance, samples will be drawn from the distribution with
#' (coeff_1, sig2_1, lbd_1) and with another 1/2 chance, they will be drawn from
#' the distribution with (coeff_2, sig2_2, lbd_2).
#'
#' @return \item{beta}{(group) lasso estimator.}
#' @return \item{subgrad}{subgradient.}
#'
#' @examples
#' set.seed(1234)
#' n <- 10
#' p <- 30
#' Niter <-  10
#' Group <- rep(1:(p/10), each = 10)
#' Weights <- rep(1, p/10)
#' x <- matrix(rnorm(n*p), n)
#' #
#' # Using non-mixture distribution
#' #
#' DirectSampler(X = x, coeff_1 = rep(0, p), sig2_1 = 1, lbd_1 = .5,
#'  weights = Weights, group = Group, niter = Niter, parallel = FALSE)
#' DirectSampler(X = x, coeff_1 = rep(0, p), sig2_1 = 1, lbd_1 = .5,
#'  weights = Weights, group = Group, niter = Niter, parallel = TRUE)
#' #
#' # Using mixture distribution
#' #
#' DirectSampler(X = x, coeff_1 = rep(0, p), sig2_1 = 1, lbd_1 = .5,
#'  coeff_2 = rep(1, p), sig2_2 = 2, lbd_2 = .3, weights = Weights,
#'  group = Group, niter = Niter, parallel = TRUE)
#' @export
#'
DirectSampler <- function(X, coeff_1, sig2_1, lbd_1, coeff_2, sig2_2, lbd_2,
  lbd, weights = rep(1, max(group)), group = 1:ncol(X), niter = 2000,
  type = "normal", Y, parallel = FALSE, ncores = 2L, verbose = FALSE)
{
  if (any(missing(coeff_1), missing(sig2_1), missing(lbd_1))) {
    stop("provide all the parameters for the distribution")
  }
  if (all(group==1:p) && !sum(c(missing(sig2_2), missing(lbd_2),
                                missing(coeff_2)))==3) {
    stop("Mixture distribution can be only used under group lasso.")
  }

  if (!sum(c(missing(sig2_2), missing(lbd_2), missing(coeff_2)))
      %in% c(0, 3)) {
    stop("provide all the parameters for the mixture distribution.")
  }

  Mixture <- !missing(sig2_2)

  if (Mixture) {
    niter1 <- rbinom(n = 1, size = niter, prob = 1/2)
    niter2 <- niter-niter1

    DS1 <- DirectSamplerMain(X = X, coeff = coeff_1, sig2 = sig2_1,
                         lbd = lbd_1, weights = weights, group = group, niter = niter1,
                         type = type, Y=Y, parallel = parallel, ncores = ncores, verbose = verbose)
    DS2 <- DirectSamplerMain(X = X, coeff = coeff_2, sig2 = sig2_1,
                         lbd = lbd_1, weights = weights, group = group, niter = niter2,
                         type = type, Y=Y, parallel = parallel, ncores = ncores, verbose = verbose)
    return(list(beta = rbind(DS1$beta, DS2$beta), subgrad = rbind(DS1$subgrad, DS2$subgrad)))
  } else {
    return(DirectSamplerMain(X = X, coeff = coeff_1, sig2 = sig2_1,
                  lbd = lbd_1, weights = weights, group = group, niter = niter,
                  type = type, Y=Y, parallel = parallel, ncores = ncores, verbose = verbose))
  }
}


DirectSamplerMain <- function(X, coeff, sig2, lbd, weights = rep(1, max(group)),
 group = 1:ncol(X), niter = 2000, type = "normal", Y, parallel = FALSE,
 ncores = 2L, verbose = FALSE)
{
  n <- nrow(X);
  p <- ncol(X);

  if (parallel && !missing(ncores) && ncores == 1) {
    ncores <- 2
    warning("If parallel=TRUE, ncores needs to be greater than 1. Automatically
            Set ncores to the maximum number.")
  }

  if (missing(Y) && type == "nonparametric") {
    stop("Y is needed for the type=\"nonparametric\"")
  }
  if (parallel && verbose) {
    warning("Note that verbose only works when parallel=FALSE")
  }
  if (length(coeff) != p) {
    stop("coeff must have a same length with the number of X columns")
  }
  if (length(group) != p) {
    stop("group must have a same length with the number of X columns")
  }
  if (length(weights) != length(unique(group))) {
    stop("weights has to have a same length as the number of groups")
  }
  if (type %in% c("normal", "nonparametric") == FALSE){
    stop("type needs to be either normal or nonparametric")
  }
  if (any(!1:max(group) %in% group)) {
    stop("Group index has to be a consecutive integer.")
  }


  if(verbose) {
    ptm <- proc.time();
    niter.seq <- round(seq(1, niter, length.out = 11))[-1]
  }

  W <- rep(weights, table(group))

  X.tilde   <- scale(X, FALSE, scale = W)
  t.X.tilde <- t(X.tilde) # same as  t(X) / W
  GramMat   <- t(X.tilde) %*% X.tilde
  Lassobeta <- matrix(0, niter, p)
  Subgrad   <- matrix(0, niter, p)
  Ysample   <- numeric(n)
  Yexpect   <- X %*% coeff

  if(type == "nonparametric"){obsRed <- Y - Yexpect;}

  FF <- function(x) {
    if(type == "normal")
    {
      epsilon <- rnorm(n, mean = 0, sd = sig2^0.5)
    }
    if(type == "nonparametric")
    {
      epsilon <- sample(obsRed, size = n, replace = TRUE);
    }
    Ysample <- Yexpect + epsilon;
    #if(center){Ysample=Ysample-mean(Ysample);}

    LassoFit <- gglasso(X.tilde, Ysample, pf = rep(1, max(group)),
                  group = group, loss = "ls", intercept = FALSE, lambda = lbd)
    Lassobeta <- coef(LassoFit)[-1] / W
    return(c(Lassobeta, (t.X.tilde %*% Ysample -
                           GramMat %*% (Lassobeta * W)) / n / lbd))
  }

  if (parallel == FALSE) {
    TEMP      <- lapply(1:niter, FF)
    TEMP      <- do.call(rbind, TEMP)
    Lassobeta <- TEMP[, 1:p]
    Subgrad   <- TEMP[, -c(1:p)]
  } else {
    if (ncores > parallel::detectCores()){
      ncores <- parallel::detectCores()
      warnings("ncores is larger than the maximum number of available processes.
               Set it to the maximum possible value.")
    }
    TEMP <- parallel::mclapply(1:niter, FF, mc.cores = ncores)
    TEMP <- do.call(rbind, TEMP)
    Lassobeta <- TEMP[, 1:p]
    Subgrad <- TEMP[, -c(1:p)]
  }
  if(verbose) {print(proc.time() - ptm)}
  return(list(beta = Lassobeta, subgrad = Subgrad));
}




