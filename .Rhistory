PEtype = "coeff", verbose = FALSE)
, "length")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = -1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "sig2 and/or lbd")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 0,
B0 = B0, S0 = S0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "sig2 and/or lbd")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = rep(0,p), niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "Invalid S0")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, burnin = 0, FlipSA = 1:p,
PEtype = "coeff", verbose = FALSE)
, "FlipSA has to be a subset")
})
context("Metropolis Hastings")
#-------------------------
# Low dim
#-------------------------
set.seed(123)
n <- 10
p <- 5
X <- matrix(rnorm(n * p), n)
Y <- X %*% rep(1, p) + rnorm(n)
sigma2 <- 1
lbd <- .37
weights <- rep(1, p)
LassoResult <- Lasso.MHLS(X = X, Y = Y, type = "lasso", lbd = lbd, weights = weights)
B0 <- LassoResult$B0
S0 <- LassoResult$S0
test_that("Low dimensional setting under lasso setting", {
# Expect NA
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE), NA)
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE), NA)
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, A = 1:p, burnin = 0,
PEtype = "coeff", verbose = FALSE), NA)
expect_error(MHLS(X = X, PE = rep(0, n), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, burnin = 0,
PEtype = "mu", verbose = FALSE), NA)
expect_error(MHLS(X = X, PE = rep(0, n), sig2 = 1, lbd = 1,
B0 = B0, niter = 50, burnin = 0,
PEtype = "mu", verbose = FALSE), NA)
expect_error(MHLS(X = X, PE = rep(0, n), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, A = 1:p, burnin = 0,
PEtype = "mu", verbose = FALSE), NA)
# Expect error
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, A = 1:(p+1), niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "Invalid active")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, A = c(1,1:p), niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "Invalid active")
expect_error(MHLS(X = X, PE = rep(0, p-1), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "length")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = c(0,B0), S0 = S0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "length")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = c(0,S0), niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "length")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = -1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "sig2 and/or lbd")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 0,
B0 = B0, S0 = S0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "sig2 and/or lbd")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = rep(0,p), niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "Invalid S0")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, burnin = 0, FlipSA = 1:p,
PEtype = "coeff", verbose = FALSE)
, "FlipSA has to be a subset")
})
# set.seed(123)
# n <- 10
# p <- 5
# X <- matrix(rnorm(n * p), n)
# Y <- X %*% rep(1, p) + rnorm(n)
# sigma2 <- 1
# lbd <- 1
# group <- c(1, 1, 2, 2, 2)
# weights <- rep(1, max(group))
# LassoResult <- Lasso.MHLS(X = X, Y = Y, type = "grlasso", group = group, lbd = lbd, weights = weights)
# B0 <- LassoResult$B0
# S0 <- LassoResult$S0
#
#
# test_that("Low dimensional setting under group lasso setting", {
#   # Expect NA
#   expect_error(MHLS(X = X, PE = rep(0, 5), sig2 = 1, lbd = 1,
#                     B0 = B0, S0 = S0, group = group, niter = 50,
#                     burnin = 0, PEtype = "coeff", verbose = FALSE), NA)
#   expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
#                     B0 = B0, S0 = S0, group = group, niter = 50, A = c(1, 2),
#                     burnin = 0, PEtype = "coeff", verbose = FALSE), NA)
#   # Expect error
#   expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
#                     B0 = B0, group = group, niter = 50, burnin = 0,
#                     PEtype = "coeff", verbose = FALSE)
#                , "Missing S0")
#   expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
#                     B0 = B0, S0 = S0, group = group, A = 1:(p+1), niter = 50, burnin = 0,
#                     PEtype = "coeff", verbose = FALSE)
#                , "Invalid active")
#   expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
#                     B0 = B0, S0 = S0, group = group, A = c(1,1:p), niter = 50, burnin = 0,
#                     PEtype = "coeff", verbose = FALSE)
#                , "Invalid active")
#   expect_error(MHLS(X = X, PE = rep(0, p-1), sig2 = 1, lbd = 1,
#                     B0 = B0, S0 = S0, group = group, niter = 50, burnin = 0,
#                     PEtype = "coeff", verbose = FALSE)
#                , "length")
#   expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
#                     B0 = c(0,B0), S0 = S0, group = group, niter = 50, burnin = 0,
#                     PEtype = "coeff", verbose = FALSE)
#                , "length")
#   expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
#                     B0 = B0, S0 = c(0,S0), group = group, niter = 50, burnin = 0,
#                     PEtype = "coeff", verbose = FALSE)
#                , "length")
#   expect_error(MHLS(X = X, PE = rep(0, p), sig2 = -1, lbd = 1,
#                     B0 = B0, S0 = S0, group = group, niter = 50, burnin = 0,
#                     PEtype = "coeff", verbose = FALSE)
#                , "sig2 and/or lbd")
#   expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 0,
#                     B0 = B0, S0 = S0, group = group, niter = 50, burnin = 0,
#                     PEtype = "coeff", verbose = FALSE)
#                , "sig2 and/or lbd")
#   expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
#                     B0 = B0, S0 = rep(0,p), group = group, niter = 50, burnin = 0,
#                     PEtype = "coeff", verbose = FALSE)
#                , "Invalid S0")
# })
#-------------------------
# High dim
#-------------------------
set.seed(123)
n <- 5
p <- 10
X <- matrix(rnorm(n*p),n)
Y <- X %*% rep(1,p) + rnorm(n)
sigma2 <- 1
lbd <- .37
weights <- rep(1,p)
LassoResult <- Lasso.MHLS(X = X,Y = Y, type = "lasso", lbd = lbd,weights = weights)
B0 <- LassoResult$B0
S0 <- LassoResult$S0
A <- which(B0!=0)
test_that("Low dimensional setting under lasso setting", {
# Expect NA
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE), NA)
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE), NA)
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, A = c(1,2,A), burnin = 0,
PEtype = "coeff", verbose = FALSE), NA)
# Expect error
# expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
#                   group = rep(c(1,2),each=5), B0 = B0, S0 = S0, niter = 50,
#                   burnin = 0, PEtype = "coeff")
#              , "Low dimensional data")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, A = 0:(p-1), niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "Invalid active")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, A = c(1,1:p), niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "Invalid active")
expect_error(MHLS(X = X, PE = rep(0, p-1), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "length")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = c(0,B0), S0 = S0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "length")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = c(0,S0), niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "length")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = -1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "sig2 and/or lbd")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 0,
B0 = B0, S0 = S0, niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "sig2 and/or lbd")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = rep(0,p), niter = 50, burnin = 0,
PEtype = "coeff", verbose = FALSE)
, "Invalid S0")
expect_error(MHLS(X = X, PE = rep(0, p), sig2 = 1, lbd = 1,
B0 = B0, S0 = S0, niter = 50, burnin = 0, FlipSA = 1:p,
PEtype = "coeff", verbose = FALSE)
, "FlipSA has to be a subset")
})
example(lars::cv.lars)
?lars::cv.lars
data(diabetes)
attach(diabetes)
cv.lars(x2,y,trace=TRUE,max.steps=80)
detach(diabetes)
library(lars)
data(diabetes)
attach(diabetes)
cv.lars(x2,y,trace=TRUE,max.steps=80)
detach(diabetes)
CV <- cv.lars(x2,y)
attach(diabetes)
CV <- cv.lars(x2,y)
str(CV)
?glmnet::cv.glmnet
example(glmnet::cv.glmnet)
library(glmnet)
example(cv.glmnet)
fit1_cv
set.seed(123)
n <- 30
p <- 50
group <- rep(1:(p/10),each=10)
weights <- rep(1, max(group))
X <- matrix(rnorm(n*p),n)
truebeta <- c(rep(1,5),rep(0,p-5))
Y <- X%*%truebeta + rnorm(n)
type="grlasso"
num.lbdseq=100
plot.it=TRUE
K = 10L
ncores = 8
parallel=T
n <- nrow(X)
p <- ncol(X)
Y <- as.vector(Y)
K <- as.integer(K)
num.lbdseq <- as.integer(num.lbdseq)
minlbd <- 0
max(t(X) %*% Y)
type
maxlbd
maxlbd <- if (type %in% c("lasso", "grlasso")) {max(t(X) %*% Y)} else {2}
maxlbd
verbose=T
all.folds <- split(sample(1:n), rep(1:K, length = n))
#index=seq(0,max(t(X)%*%Y),length=100)
index <- seq(minlbd,maxlbd,length=num.lbdseq)[-1]
residmat <- matrix(0, length(index), K)
FF <- function(x,omit) {
fit <- Lasso.MHLS(X=X[-omit,,drop=FALSE],Y=Y[-omit],type=type,
lbd=index[x],group=group,weights=weights)$B0
fit <- X[omit,,drop=FALSE]%*%fit
return(mean((Y[omit]-fit)^2))
}
for (i in seq(K)) {
omit <- all.folds[[i]]
residmat[,i] <- do.call(rbind,parallel::mclapply(1:length(index),
FF,omit = omit, mc.cores = ncores))
if(verbose) {cat("\n CV Fold", i, "\n\n")}
}
all.folds
index
residmat <- matrix(0, length(index), K)
i=1
omit <- all.folds[[i]]
x
x=1
fit <- Lasso.MHLS(X=X[-omit,,drop=FALSE],Y=Y[-omit],type=type,
lbd=index[x],group=group,weights=weights)$B0
fit <- X[omit,,drop=FALSE]%*%fit
library(EAlasso)
for (i in seq(K)) {
omit <- all.folds[[i]]
residmat[,i] <- do.call(rbind,parallel::mclapply(1:length(index),
FF,omit = omit, mc.cores = ncores))
if(verbose) {cat("\n CV Fold", i, "\n\n")}
}
cv <- apply(residmat, 1, mean)
cvsd <- apply(residmat, 1, sd)
index.min.cv <- which.min(cv)
cv
cv <- apply(residmat, 1, mean)
cvsd <- apply(residmat, 1, sd)
index.min.cv <- which.min(cv)
err.1se <- cvsd[index.min.cv] + cv[index.min.cv]
lbd.1se <- index[which.min(abs(cv - err.1se))]
lbd.min <- index[index.min.cv]
if (plot.it) {
matplot(x=index, y=cbind(cv,cv-cvsd,cv+cvsd), type="l",
lty=c(1,2,2), col=c(1,2,2),
xlab="lambda",ylab="squared error",
main="cross validation")
abline(v=lbd.min,lty=2)
abline(v=lbd.1se,lty=3)
}
maxlbd
Lasso.MHLS(X,Y,type="grlasso",lbd=maxlbd,group=group,weights=weights)$B0
Lasso.MHLS(X,Y,type="grlasso",lbd=maxlbd/10,group=group,weights=weights)$B0
Lasso.MHLS(X,Y,type="grlasso",lbd=maxlbd/n,group=group,weights=weights)$B0
Lasso.MHLS(X,Y,type="grlasso",lbd=maxlbd/20,group=group,weights=weights)$B0
Lasso.MHLS(X,Y,type="grlasso",lbd=maxlbd/15,group=group,weights=weights)$B0
1:3 * matrix(1:6,2)
1:3 * matrix(1:6,3)
max(abs(1/W * t(X) %*% Y))/n
max(abs(1/weights * t(X) %*% Y))/n
lbdTEMP <- c()
for (i in 1:max(group)) {
lbdTEMP[i] <- sqrt(crossprod(t(X[,group==i])%*%Y))/weights[i]
}
max(lbdTEMP / n)
maxlbd <- if (type == "lasso")
{
max(abs(1/weights * t(X) %*% Y))/n
} else if (type == "grlasso")
{
lbdTEMP <- c()
for (i in 1:max(group)) {
lbdTEMP[i] <- sqrt(crossprod(t(X[,group==i])%*%Y))/weights[i]
}
max(lbdTEMP / n)
} else {2}
maxlbd
Lasso.MHLS(X,Y,type="grlasso",lbd=maxlbd,group=group,weights=weights)$B0
Lasso.MHLS(X,Y,type="grlasso",lbd=maxlbd-.1,group=group,weights=weights)$B0
Lasso.MHLS(X,Y,type="grlasso",lbd=maxlbd-.01,group=group,weights=weights)$B0
all.folds <- split(sample(1:n), rep(1:K, length = n))
#index=seq(0,max(t(X)%*%Y),length=100)
index <- seq(minlbd,maxlbd,length=num.lbdseq)[-1]
residmat <- matrix(0, length(index), K)
FF <- function(x,omit) {
fit <- Lasso.MHLS(X=X[-omit,,drop=FALSE],Y=Y[-omit],type=type,
lbd=index[x],group=group,weights=weights)$B0
fit <- X[omit,,drop=FALSE]%*%fit
return(mean((Y[omit]-fit)^2))
}
for (i in seq(K)) {
omit <- all.folds[[i]]
residmat[,i] <- do.call(rbind,parallel::mclapply(1:length(index),
FF,omit = omit, mc.cores = ncores))
if(verbose) {cat("\n CV Fold", i, "\n\n")}
}
#apply(residmat, 2, which.min)
cv <- apply(residmat, 1, mean)
cvsd <- apply(residmat, 1, sd)
index.min.cv <- which.min(cv)
cv
matplot(x=index, y=cbind(cv,cv-cvsd,cv+cvsd), type="l",
lty=c(1,2,2), col=c(1,2,2),
xlab="lambda",ylab="squared error",
main="cross validation")
err.1se <- cvsd[index.min.cv] + cv[index.min.cv]
lbd.min <- index[index.min.cv]
lbd.min
index.min.cv
index.min.cv:num.lbdseq
which.min(abs(cv - err.1se)[index.min.cv:num.lbdseq])
which.min(abs(cv - err.1se))
library(EAlasso)
cv.lasso(X,Y,group,weights,K=10,type="sgrlasso",num.lbdseq=100,plot.it=TRUE)
library(EAlasso)
cv.lasso(X,Y,group,weights,K=10,type="sgrlasso",num.lbdseq=100,plot.it=TRUE)
cv.lasso(X,Y,group,weights,K=10,type="grlasso",num.lbdseq=100,plot.it=TRUE)
?cv.lars
cv.lars
data(diabetes)
attach(diabetes)
cv.lars(x2,y,trace=TRUE,max.steps=80)
detach(diabetes)
library(EAlasso)
devtools::load_all(".")
?PBsampler
?PBsampler
library(EAlasso)
library(EAlasso)
?PBsampler
library(EAlasso)
?PBsampler
library(EAlasso)
?PBsampler
library(EAlasso)
?PBsampler
?hdIS
?MHLS
library(EAlasso)
?MHLS
library(EAlasso)
?MHLS
library(EAlasso)
library(EAlasso)
?MHLS
library(EAlasso)
?MHLS
example(plot.MHLS)
?plot.MHLS
devtools::build_win()
?devtools::build_win
devtools::build_win(version="R-devel")
devtools::build_win(version="R-release")
library(EAlasso)
devtools::build_win(version="R-release")
devtools::build_win(version="R-devel")
cv.lasso(X,Y,group,weights,K=2,type="sgrlasso",num.lbdseq=2,plot.it=FALSE)
library(EAlasso)
example(cvlasso)
example(cv.lasso)
library(EAlasso)
devtools::build_win(version="R-devel")
devtools::build_win(version="R-release")
R.version
.sessionInfo
sessionInfo()
devtools::release()
devtools::release()
install.packages("roxgen2")
install.packages("roxygen2")
install.packages("gglasso")
install.packages("msm")
install.packages("mvtnorm")
install.packages("ggm")
install.packages("limSolve")
install.packages("glmnet")
library(EAlasso)
install.packages("knitr")
library(EAlasso)
install.packages("testthat")
install.packages("rmarkdown")
library(glmnet)
?print.glmnet
set.seed(123)
n <- 10
p <- 5
X <- matrix(rnorm(n * p), n)
Y <- X %*% rep(1, p) + rnorm(n)
lbd <- .37
weights <- rep(1, p)
LassoResult <- Lasso.MHLS(X = X, Y = Y, lbd = lbd, type="lasso", weights = weights)
LassoResult <- Lasso.MHLS(X = X, Y = Y, lbd = lbd, type="lasso", weights = weights)
B0 <- LassoResult$B0
S0 <- LassoResult$S0
Result <- MHLS(X = X, PE = rep(0, p), sig2 = sigma2, lbd = lbd, group = 1:p,
weights = weights, B0 = B0, S0 = S0, niter = 50, burnin = 0,
type = "coeff")
sigma2 <- 1
Result <- MHLS(X = X, PE = rep(0, p), sig2 = sigma2, lbd = lbd, group = 1:p,
weights = weights, B0 = B0, S0 = S0, niter = 50, burnin = 0,
type = "coeff")
print(Result)
names(Result)
x=matrix(rnorm(100*20),100,20)
y=rnorm(100)
fit1=glmnet(x,y)
print(fit1)
str(fit1)
?print.MHLS
library(EAlasso)
?summary.MHLS
library(EAlasso)
?summary.MHLS
library(EAlasso)
?summary.MHLS
library(EAlasso)
?summary.MHLS
library(EAlasso)
?summary.MHLS
?summary.MHLS
?plot.MHLS
?plot
plot.glmnet
?plot.glmnet
example(plot.MHLS)
?Lasso.MHLS
library(EAlasso)
library(EAlasso)
?Lasso.MHLS
library(EAlasso)
?Lasso.MHLS
library(EAlasso)
?Postinference.MHLS
library(EAlasso)
?cv.lasso
library(EAlasso)
?cv.lasso
library(EAlasso)
library(EAlasso)
library(EAlasso)
install.packages("devtools")
devtools::build_win(version = "R-release")
devtools::build_win(version = "R-develop")
devtools::build_win(version = "R-devel")
devtools::release()
